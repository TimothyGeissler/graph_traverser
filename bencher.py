from algs.DFS import DFS
from algs.BFS import BFS
from graph import Graph, Node
from algs.Dijkstra import Dijkstra

import matplotlib.pyplot as plt
import networkx as nx
import numpy as np
import time


# Visualizes the graph traversal path generated by the algorithm
def visualize_graph(graph, traversal_result=None):
    G = nx.Graph()
    for node_name, node in graph.nodes.items():
        G.add_node(node_name)
        for neighbor in node.neighbors:
            G.add_edge(node_name, neighbor.name)

    pos = nx.spring_layout(G)
    plt.figure(figsize=(8, 6))
    nx.draw(G, pos, with_labels=True, node_color='skyblue', node_size=1500, edge_color='black', linewidths=1,
            font_size=15, arrows=False)

    if traversal_result:
        nx.draw_networkx_nodes(G, pos, nodelist=traversal_result, node_color='r', node_size=1500)
        plt.title('Graph Traversal Visualization')
    else:
        plt.title('Graph Visualization')

    plt.show()


# Generate adjacency matrix of size n*n
def gen_adj_matrix(n, seed=None):
    np.random.seed(seed)
    # Initialize an n*n matrix with all zeros
    adjacency_matrix = np.zeros((n, n), dtype=int)

    # Randomly assign 1s to represent directed edges
    for i in range(n):
        for j in range(n):
            # To prevent self-loops, do not allow an edge from a node to itself
            if i != j:
                adjacency_matrix[i][j] = np.random.choice([0, 1])

    return adjacency_matrix


def measure_average_runtime(alg, n_values, num_iterations, seed=None):
    average_runtimes = []
    for n in n_values:
        runtimes = []
        for _ in range(num_iterations):
            # Generate adjacency matrix for size n with fixed seed
            adjacency_matrix = gen_adj_matrix(n, seed)

            # Create graph object
            adj_graph = Graph(adjacency_matrix)

            # Measure time for DFS traversal from Node_1 to Node_4
            start_time = time.time()

            if alg == 'DFS':
                DFS(adj_graph).traverse("Node_1", "Node_100")
            elif alg == 'BFS':
                BFS(adj_graph).traverse("Node_1", "Node_100")
            elif alg == 'Dijkstra':
                Dijkstra(adj_graph).traverse("Node_1", "Node_99")

            end_time = time.time()

            runtimes.append(end_time - start_time)
        average_runtimes.append((n, np.mean(runtimes), np.std(runtimes)))
    return average_runtimes


def performance_plot(alg, start=100, end=1001, count=5, iterations=5):
    # Generate n values from 100 to 1000 in increments of 50
    print("Running performance analysis on " + alg)
    increment = (start - end) / count
    n_values = list(range(start, end, 200))

    # Number of iterations for averaging runtime

    # Measure average runtime and standard deviation for each n with fixed seed
    average_runtimes = measure_average_runtime(alg, n_values, iterations, seed=42)

    # Extract n, average runtime, and standard deviation values for plotting
    n_values, runtime_values, std_values = zip(*average_runtimes)

    # Plotting
    plt.figure(figsize=(10, 6))
    # plt.errorbar(n_values, runtime_values, yerr=std_values, fmt='o', color='b', ecolor='r', linestyle='-')
    plt.plot(n_values, runtime_values, marker='o', linestyle='-', color='b')
    plt.title('Average Runtime of ' + alg + ' Traversal vs. Graph Size (n)')
    plt.xlabel('Graph Size (n)')
    plt.ylabel('Average Runtime (seconds)')
    plt.grid(True)
    plt.show()


if __name__ == "__main__":
    # Example graph setup
    graph = Graph()
    node1 = Node("A")
    node2 = Node("B")
    node3 = Node("C")
    node4 = Node("D")
    node5 = Node("E")
    node6 = Node("F")
    graph.add_node(node1)
    graph.add_node(node2)
    graph.add_node(node3)
    graph.add_node(node4)
    graph.add_node(node5)
    graph.add_node(node6)
    graph.add_edge("A", "B")
    graph.add_edge("A", "C")
    graph.add_edge("B", "C")
    graph.add_edge("B", "D")
    graph.add_edge("B", "F")
    graph.add_edge("C", "E")
    graph.add_edge("D", "E")
    graph.add_edge("E", "F")

    bfs_traversal = BFS(graph)
    bfs_result = bfs_traversal.traverse("A", "C")
    # print("BFS Traversal:", bfs_result)
    # visualize_graph(graph, bfs_result)

    # Using DFS traversal
    dfs_traversal = DFS(graph)
    dfs_result = dfs_traversal.traverse("A", "C")
    # print("DFS Traversal:", dfs_traversal.traverse("A", "C"))
    # visualize_graph(graph, dfs_result)
    
    # using Dijkstras Traversal
    dij_traversal = Dijkstra(graph)
    print("Dijkstra Traversal:", dij_traversal.traverse("A", "F"))

    # mat = [[0, 1, 1, 0],
    #        [0, 0, 0, 1],
    #        [0, 1, 0, 0],
    #        [0, 0, 0, 0]]
    # adj_graph = Graph(mat)
    # print(adj_graph.nodes)
    # visualize_graph(adj_graph)

    #performance_plot('DFS')
    performance_plot("Dijkstra")
   
